---
title: "GF.Rmd"
author: "Tanya Lama"
date: "8/21/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---
#Load Dependencies
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("/project/uma_lisa_komoroske/Tanya/scripts/GF")
library(vegan)
#gradientForest was a bit of a pain to install. This was the best method we found to install it: 
#install.packages("gradientForest", repos="http://R-Forge.R-project.org")
#alternatively you may need to install it from source here: https://r-forge.r-project.org/R/?group_id=973
library(gradientForest)
```
#SNP data
```{r}
snp <- read.table("/project/uma_lisa_komoroske/Tanya/scripts/GF/snps/LFMM_subset_snpset_0.1/snp.forR", header = T, row.names = 1)
```

#Spatial data
For the spatial variables, one could use latitude and longitude, but a more sophisticated approach might be to use PCNMs or MEMs (principal coordinates of neighbor matrices or Moran's eigenvector maps). These approaches generate a set of uncorrelated spatial variables. We do not have time to go into these methods in detail, but here is the code to generate the PCNM spatial variables.
```{r}
clim.points <-read.table("clim.points.current", header=T)
#We need to correct that one coordinate for A803
#There's an error with A803 that needs to be corrected
clim.points[37,1:3]
clim.points[37,3]<- 50.2414428
coord <- clim.points[,c("Longitude","Latitude")] 
pcnm <- pcnm(dist(coord))  #this generates the PCNMs, you could stop here if you want all of them
keep <- round(length(which(pcnm$value > 0))/2)
pcnm.keep <- scores(pcnm)[,1:keep]  #keep half of positive ones as suggested by some authors
pcnm.keep #looks good
```
#Running the GF model with all SNPs
Now we are ready to begin GF to model the associations of spatial and climate variables with allele frequencies (genotypes) of individuals. Create an object that contains only the climate and PCNM spatial variables (no lat/lon).

#Choosing a clim.points object
We actually have multiple clim.points objects. I want to try two of them: 1) with our synthetic environmental variables (PC1 PC2) from LFMM and 2) all 19 climate variables directly. 
```{r}
## Two PCs
PCs<- read.table("current_pred_pcs_clim.env", header=T)
env.gf.pcs <- cbind(PCs, pcnm.keep)
maxLevel <- log2(0.368*nrow(env.gf.pcs)/2)

#Running GF involves only one command:
gf.pcs <- gradientForest(cbind(env.gf.pcs, snp), predictor.vars=colnames(env.gf.pcs), response.vars=colnames(snp), ntree=1, maxLevel=maxLevel, trace=T, corr.threshold=0)

save(gf.pcs, file = "gf.pcs.model.rda")
```
#All 19 variables: go with this
```{r}
env.gf <- cbind(clim.points[,4:22], pcnm.keep)
#In GF, a maximum number of splits to evaluate can be defined following the developers suggestion

maxLevel <- log2(0.368*nrow(env.gf)/2)

#Running GF involves only one command:
gf <- gradientForest(cbind(env.gf, snp), predictor.vars=colnames(env.gf), response.vars=colnames(snp), ntree=1, maxLevel=maxLevel, trace=T, corr.threshold=0)

gf
names(gf)
save(gf, file = "gf_model.rda")
```
Typical parameterization: n trees (500), compact = T, nbin= 200, correlation threshold=0.5. The summary called by gf and names(gf) shows the number of "species" with positive R2 i.e. sepcies that could be predicted by the available predictors. The gf list contains the data, predictor importances, species R2s, etc. 

#gradientForest plots
Several types of plots are available for the gradientForest object. 

#1. The first is the predictor overall importance plot. 
This show the mean accuracy importance and the mean importanceweighted by species R2. Both are conditional importance. BIO5 and BIO13 are clearly the most important variables across these 61 species followed by likely BIO3
BIO5 = Max Temperature of Warmest Month
BIO13 = Precipitation of Wettest Month
BIO3 = Isothermality (BIO2/BIO7) (Ã—100)

The PCNM approach was supposed to result in uncorrelated spatial variables, yet we see these coming up as top predictors, which is not good. Maybe we should just go ahead and use regular Lat Long
```{r} 
#pdf("GF_VariableImportance.pdf")
plot(gf, plot.type = "O", cex.axis=0.4, cex=0.4)
#dev.off()

#The predictor gradient plots are best presented in order of importance; in this example the top 25 predictors are presented in 5 by 5 panels.

#Which variables are most important?
most_important <- names(importance(gf))
top_variables<- c("wc2.1_10m_bio_12", "wc2.1_10m_bio_7", "wc2.1_10m_bio_10", "wc2.1_10m_bio_8", "wc2.1_10m_bio_3")
```
#2. The splits density plot (plot.type="S")
Shows binned split importance and location on each gradient (spikes), kernel density of splits (black lines), of observations (red lines) and of splits standardised by observations density (blue lines). Each distribution integrates to predictor importance. These show where important changes in the abundance of multiple species are occurring along the gradient; they indicate a composition change rate. Many of the usual plot options can be set in the call.
```{r}
plot(gf, plot.type = "S", imp.vars = top_variables,
leg.posn = "topleft", cex.legend = 1, cex.axis = 0.6,
cex.lab = 0.7, line.ylab = 0.9, par.args = list(mgp = c(1.5,
0.5, 0), mar = c(3.1, 1.5, 1, 1)))
```

#3. The species cumulative plot (plot.type="C", show.overall=F)
This plot show cumulative importance distributions of splits improvement scaled by R2 weighted importance, and standardized by density of observations for each "species". These show cumulative change in abundance of individual species, where changes occur on the gradient, and the species changing most on each gradient. 
```{r}
plot(gf, plot.type = "C", imp.vars = most_important,
show.overall = F, legend = T, leg.posn = "topleft",
leg.nspecies = 1, cex.lab = 0.7, cex.legend = 0.4,
cex.axis = 0.6, line.ylab = 0.9, par.args = list(mgp = c(1.5,
0.5, 0), mar = c(2.5, 1, 0.1, 0.5), omi = c(0,
0.3, 0, 0)))

#couldn't get this one to work??
```

#4. Predictor cumulative plot
For each predictor, this plot shows the cumulative importance distribution of splits improvement scaled by R2 weighted importance and standardized by density of observations, averaged over all species. These show cumulative change in overall composition of the community, where changes occur on the gradient. 
```{r}
plot(gf, plot.type = "C", imp.vars = top_variables,
show.species = F, common.scale = T, cex.axis = 0.8,
cex.lab = 1, line.ylab = 0.9, par.args = list(mgp = c(1.5,
0.5, 0), mar = c(2.5, 1, 1, 1), omi = c(0,
0.3, 0, 0)))
```
#5. R2 measure of the fit of the random forest model for each individual, ordered in various ways
```{r}
plot(gf, plot.type = "P", show.names = F, horizontal = F,
cex.axis = 1, cex.labels = 0.7, line = 2.5)
plot(gf, plot.type = "P", show.names = T, horizontal = F,
cex.axis = 1, cex.labels = 0.7, line = 2.5)
plot(gf, plot.type = "P", show.names = F, horizontal = T,
cex.axis = 1, cex.labels = 0.6, line = 2.5)
plot(gf, plot.type = "P", show.names = T, horizontal = T,
cex.axis = 1, cex.labels = 0.6, line = 2.5)
```

These are the "turnover functions" described in Fitzpatrick et al. showing how allelic composition changes along the spatial or environmental gradients. The shapes are nonlinear and large jumps show steep genetic changes along certain portions of the environmental gradient. The height that the function achieves on the right side of the plot is the total importance and should match the barplot. First, organize the variables by importance and then plot:

by.importance <- names(importance(gf))

#Cumulative importance (turnover) by SNP. 
plot(gf, plot.type = "C", imp.vars = top_variables, show.species=T, legend = T, leg.posn = "topleft", ylim = c(0,100), cex.lab = 0.7, cex.legend = 0.4, cex.axis = 0.6, line.ylab = 0.9, par.args = list(mgp = c(1.5, 0.5, 0), mar = c(2.5, 1, 0.1, 0.5), omi = c(0, 0.3, 0, 0)))


#pdf("GF_TurnoverFunctions.pdf")
plot(gf, plot.type = "C", imp.vars = by.importance, show.species = F, common.scale = T, cex.axis = 1, cex.lab = 1.2, line.ylab = 1, par.args = list(mgp = c(1.5, 0.5, 0), mar = c(2.5, 2, 2, 2), omi = c(0.2, 0.3, 0.2, 0.4)))

#Do you see any interesting patterns? It appears that genetic variation changes abruptly for Pseas values of 60 and then acheives high cumulative importance.

#We can also make plots of turnover functions for individual loci: The third plot is the species cumulative plot (plot.type="C", show.overall=F), which for each species shows cumulative importance distributions of splits improvement scaled by R2 weighted importance, and standardised by density of observations. These show cumulative change in abundance of individual species, where changes occur on the gradient, and the species changing most on each gradient. Again many of the usual plot options can be set in the call; in this example the legend identifies the top 5 most responsive species for each predictor

#pdf("GF_TurnoverFunctions_bySNP.pdf")
plot(gf, plot.type = "C", imp.vars = by.importance, show.overall = F, legend = T, leg.posn = "topleft", leg.nspecies = 5, cex.lab = 0.7, cex.legend = 0.4, cex.axis = 0.6, ylim = c(0, 0.5), line.ylab = 0.9, par.args = list(mgp = c(1.5, 0.5, 0), mar = c(2.5, 1, 0.1, 0.5), omi = c(0, 0.3, 0, 0)))
#dev.off()


#Each line within each panel represents allelic change at a single SNP. Notice that in each panel some SNPs show very steep changes along the environmental gradient. One might consider these SNPs as candidates for involvement in local adaptation along the gradient. This approach to "outlier" detection is still being tested, but Fitzpatrick & Keller (2015) show a promising example. If interested, you can check if any of these highly associated SNPs (e.g., those listed in the plot legend) were also significant in your LFMM analyses.

#Several other plots and tables can be output from gradientForest. I recommend generating these with your own data sets, but we will skip them today.

#One of the useful features of these models is that the results can be readily projected spatially across a landscape that was not necessarily completely sampled. The mapping can be a little tricky, but first we must extract the climate data for all the cells in the climate data layer and remove missing data.

#Gradient Forest predictions
In addition to examining compositional change along environmental gradients, the predictor
cumulative functions can also be used to transform grid data layers of environmental variables
to a common biological importance scale. This transformation of the multi-dimensional environment space is to a biological space in which coordinate position represents composition
associated with the predictors. These inferred compositional patterns can be mapped in biological space and geographic space in a manner analogous to ordination, but takes into account
the non-linear and sometimes threshold changes that occur along gradients.

